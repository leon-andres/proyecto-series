# EED

En esta sección se realiza la estadística exploratoria y descriptiva de las series. Se transforman para estabilizar la varianza marginal, seanalizan las tendencias,y se hace búsqueda de posibles patrones estacionales o cíclicos determinísticos. Además se hace la exploración de relaciones no lineales para incorporarlas en los modelos de aprendizaje de máquina.

```{r librerias}
#| echo: false
#| warnings: false
#| include: false

library(dplyr)
library(readxl)
library(readr)
library(plotly)

```

```{r Datos}
#| echo: false


# Serie Hurtos

# getwd()
# DatosH <- read.csv(file = 'HURTO_A_VEH_CULOS_20250205.csv',header = T,sep = ',')
# 
# DatosH <- DatosH %>%
#   mutate(FECHA.HECHO = lubridate::dmy(FECHA.HECHO))
# 
# VH <-DatosH |>
#   select(c('FECHA.HECHO', 'CANTIDAD', 'DEPARTAMENTO', 'TIPO.DELITO')) |>
#   filter(
#     (
#       TIPO.DELITO == 'HURTO AUTOMOTORES' |
#         TIPO.DELITO == 'HURTO A MOTOCICLETAS'
#     ) & DEPARTAMENTO == 'BOGOTA D.C.'
#   ) |> 
#   group_by(FECHA.HECHO) |> 
#   summarise(VehHurt = sum(CANTIDAD)) |> 
#   arrange(FECHA.HECHO)
# 
# write_csv(x = VH, file = 'HurtoVehBogota.csv')


# Oro

# Leer el archivo asegurando que 'Pesos' sea texto
DatosO <- read_xlsx("oro.xlsx", range="A2:B314", col_names=TRUE)
colnames(DatosO) <- c("Fecha", "Pesos")
DatosO$Fecha <- as.Date(DatosO$Fecha, format = "%d/%m/%Y")



# Hurtos
DatosH <- read_csv('HurtoVehBogota.csv', col_types = c('D','i'))
colnames(DatosH) <- c('Fecha','Cantidad')



```

::: panel-tabset
## Oro

```{r OroPlotly}
#| echo: false

fig <- plot_ly(
  DatosO,
  x = ~ Fecha,
  y = ~ Pesos,
  type = 'scatter',
  mode = 'lines',
  color = I("gold")
) %>%
  layout(
    title = 'Precio Oro Regalías',
    xaxis = list(
      title = "Fecha",
      rangeselector = list(buttons = list(
        list(
          count = 1,
          label = "1y",
          step = "year",
          stepmode = "backward"
        ),
        list(
          count = 5,
          label = "5y",
          step = "year",
          stepmode = "backward"
        ),
        list(
          count = 10,
          label = "10y",
          step = "year",
          stepmode = "backward"
        ),
        list(
          count = 15,
          label = "15y",
          step = "year",
          stepmode = "backward"
        ),
        list(step = "all", label = "All")
      )),
      rangeslider = list(visible = TRUE)
    ),
    yaxis = list(title = "Gramos (COP)"),
    hovermode = "x"
  )

fig

```

## Hurtos

```{r HurtosPlotly}
#| echo: false

fig <- plot_ly(DatosH, x = ~Fecha, y = ~Cantidad, type = 'scatter', mode = 'lines',line = (list(color='purple'))) %>%
  layout(
    title = "Vehículos hurtados en Bogotá",
    xaxis = list(
      title = "Fecha",
      rangeselector = list( # Botones de zoom rápido
        buttons = list(
          list(count = 1, label = "1m", step = "month", stepmode = "backward"),
          list(count = 6, label = "6m", step = "month", stepmode = "backward"),
          list(count = 1, label = "1y", step = "year", stepmode = "backward"),
          list(step = "all")
        )
      ),
      rangeslider = list(visible = TRUE) # Agregar slider
    ),
    yaxis = list(title = "Total Hurtos"),
    hovermode = "x"
  )

fig

```
:::

# Transformación.

```{r TS}
#| echo: false

Oro <- ts(DatosO[2], start=c(1998,7), end = c(2024,6), frequency = 12)
Hurtos <- ts(DatosH$Cantidad, start = c(2003,01), frequency = 365)
```


Como ambas series son positivas se verificará la existencia de heterocedasticidad con la prueba de **Box-Cox;** ya que visualmente resulta difícil reconocer esto.

::: {.panel-tabset}
## Oro

Antes de proceder con el análisis de estacionariedad, es importante verificar si la serie presenta heterocedasticidad, es decir, si la varianza no es constante en el tiempo. Para abordar este problema, se aplicó la transformación de Box-Cox, la cual permite estabilizar la varianza de la serie mediante la selección de un parámetro $\lambda$ óptimo que maximiza la verosimilitud.

El valor de $\lambda$ obtenido fue 0.05, lo que indica que una transformación logarítmica es apropiada para estabilizar la varianza de la serie.

Después de aplicar la transformación, la variabilidad de la serie se ha reducido, y el incremento pronunciado observado a partir de 2020 es menos abrupto. Esto sugiere que la serie ahora presenta una varianza más homogénea, lo que facilita su análisis y modelado.

```{r BoxCafe}
#| echo: false

# MASS::boxcox(lm(Cafe~1), seq(0,2, length = 50))
a <-MASS::boxcox(lm(Oro~1), seq(-0.5,0.8, length = 50))
lambO = a$x[which.max(a$y)]; lambO
Lambda<-forecast::BoxCox.lambda(Oro, method ="loglik", lower = -3, upper = 3)#Encontrando el valor de Lambda
Lambda
orot<-forecast::BoxCox(Oro,lambda = 0)#Transformando los datos

MASS::boxcox(lm(Oro ~ 1),seq(-3, 5, length = 50))
MASS::boxcox(lm(orot ~ 1),seq(-3, 5, length = 50))


plot_ly( x = DatosO$Fecha, y = orot, type = 'scatter', mode = 'lines',color=I("gold")) %>%
  layout(title = 'Precio Oro regalías',
         xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))

```
Se realiza la transformación con $\lambda = 0$, y se realiza de nuevo la prueba.


```{r TransOro}
#| echo: false

DatosO <- DatosO |> 
  mutate(BC = log(Pesos))


Oro_lamb <- ts(DatosO$BC, start = c(1998,7), end = c(2024,6), frequency = 12)


# plot_ly( x = time(orot), y = orot, type = 'scatter', mode = 'lines',color=I("gold")) %>%
#   layout(title = 'Precio Oro regalías',
#          xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))

fig <- plot_ly(
  DatosO,
  x = ~ Fecha,
  y = ~ BC,
  type = 'scatter',
  mode = 'lines',
  color = I("gold")
) %>%
  layout(
    title = 'Precio del gramo de Oro transformada ',
    xaxis = list(
      title = "Fecha",
      rangeselector = list(buttons = list(
        list(
          count = 1,
          label = "1y",
          step = "year",
          stepmode = "backward"
        ),
        list(
          count = 5,
          label = "5y",
          step = "year",
          stepmode = "backward"
        ),
        list(
          count = 10,
          label = "10y",
          step = "year",
          stepmode = "backward"
        ),
        list(
          count = 15,
          label = "15y",
          step = "year",
          stepmode = "backward"
        ),
        list(step = "all", label = "All")
      )),
      rangeslider = list(visible = TRUE)
    ),
    yaxis = list(title = "Log(Precio)"),
    hovermode = "x"
  )

fig



MASS::boxcox(lm(Oro_lamb~1), seq(-5,5, length = 50))

```

Parece ser que la varianza se estabilizó.


## Hurtos

```{r BCHurto}
#| echo: false

a <-MASS::boxcox(lm(Hurtos~1), seq(0.4,0.8, length = 50))
lambH = a$x[which.max(a$y)]; lambH


```


El intervalo de confianza para $\lambda$ sugiere que se debe hacer una transformación de la serie pues no contiene el 1. El valor de $\lambda =0.5090909$, entonces se hará esta transformación.


```{r TransHurto}
#| echo: false

DatosH <- DatosH |> 
  mutate(BC = (Hurtos ^ lambH - 1) / lambH)

Hurtos_lamb <- ts(DatosH$BC, start = c(2003,01), frequency = 365)
plot.ts(Hurtos_lamb, col = 'purple', main = 'Hurtos transformada')

MASS::boxcox(lm(Hurtos_lamb + 0.01 ~1), seq(0.8,1.2, length = 50))

# MODS Variables mayores  a 0.3 sugiere multicolinealidad

```

La estabilización de la varianza parace ser efectiva.

:::

# Componente de tendencia.

::: {.panel-tabset}
## Oro

### Extracción de la tendencia

En esta sección, se explorarán diferentes métodos para extraer la tendencia de la serie con el objetivo de estabilizar su comportamiento y facilitar su análisis. Para ello, se considerarán cuatro enfoques: la estimación de la tendencia mediante un modelo lineal, una estimación paramétrica, la diferenciación ordinaria y el uso de un promedio móvil. Cada método permitirá evaluar cómo se comporta la serie sin la influencia de su tendencia y determinar cuál es el más adecuado para el análisis posterior.

### Estimación de la Tendencia mediante un Modelo Lineal

Para analizar la tendencia de la serie, se ajustó un modelo de regresión lineal en función del tiempo. La ecuación resultante describe la relación entre el precio del oro y el tiempo, permitiendo capturar la tendencia general de la serie.


```{r OroTendLineal}
#| echo: false

summary(fitLM <- lm(Oro_lamb~time(Oro_lamb), na.action=NULL))#Creando un modelo de regresión lineal
plot(Oro_lamb, ylab="log(pesos)",xlab="Mes", main='Estimación de la tendencia M.Lineal') 
abline(fitLM,col = "green")


bmnoLM=orot-predict(fitLM)#Eliminando la tendencia
plot_ly( x = DatosO$Fecha, y = bmnoLM, type = 'scatter', mode = 'lines',color=I("gold")) %>%
  layout(title = 'Precio Oro regalías',
         xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))


```

Al graficar la serie junto con la recta ajustada, se observa que el modelo lineal captura la dirección general del crecimiento del precio del oro. Sin embargo, dado que la serie presenta variaciones no lineales, este modelo podría no ser suficiente para describir completamente su comportamiento a lo largo del tiempo. Por ello, será necesario comparar este enfoque con otros métodos de extracción de tendencia.

### Estimación de la Tendencia mediante un Método No Paramétrico

Para extraer la tendencia de manera más flexible, se aplicó un método no paramétrico basado en suavizamiento local. Se utilizó un modelo LOESS con un parámetro de suavización de 0.2 y grado polinómico de 2, lo que permite capturar variaciones más sutiles en la serie sin imponer una estructura rígida.


```{r OroSTL}
#| echo: false
#| warning: false


# Convertir el índice de tiempo en formato de fecha
indice1 = zoo::as.Date(zoo::as.yearmon(stats::time(Oro_lamb))) # Convirtiendo el índice de bmtsbox a fecha

# Creando el objeto tsibble
df = data.frame(Fecha = indice1, Transoro = as.numeric(Oro_lamb)) # Asegurar que TransBM sea numérico
bmTibbleTS = tsibble::as_tsibble(df)


# Creando una nueva columna con los datos ajustados por una regresión STL
df %>%
  mutate(Transoro_Mod = timetk::smooth_vec(Transoro, span = 0.2, degree = 2)) %>%
  ggplot(aes(Fecha, Transoro)) +
  geom_line() +
  geom_line(aes(y = Transoro_Mod), color = "red")


```

Al comparar la serie original con la estimación suavizada, representada en rojo, se observa que la tendencia estimada sigue el comportamiento general de los datos, pero sin verse afectada por fluctuaciones de corto plazo. Esto permite obtener una representación más clara de la evolución del precio del oro sin asumir una forma funcional específica.



```{r}
#| echo: false
STLextra<-Oro_lamb-timetk::smooth_vec(Oro_lamb,span = 0.2, degree = 2)
plot_ly( x = DatosO$Fecha, y = STLextra, type = 'scatter', mode = 'lines',color=I("gold")) %>%
  layout(title = 'Oro sin tendencia via STL',
         xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))

```

### Diferencia ordinaria

```{r OroDiff}
#| echo: false

DatosO <- DatosO |> 
  mutate(Diff = c(NA,diff(Oro_lamb)))

# Objeto ts de la serie diff.
DiferenciaOrd<-diff(Oro_lamb)

fig <- plot_ly(DatosO, x = ~Fecha, y = ~ Diff, type = 'scatter', mode = 'lines', line = (list(color='Gold'))) %>%
  layout(
    title = "Café transformada primera diferencia",
    xaxis = list(
      title = "Fecha",
      rangeselector = list( # Botones de zoom rápido
        buttons = list(
          list(count = 1, label = "1y", step = "year", stepmode = "backward"),
          list(count = 5, label = "5y", step = "year", stepmode = "backward"),
          list(count = 10, label = "10y", step = "year", stepmode = "backward"),
          list(count = 20, label = "20y", step = "year", stepmode = "backward"),
          list(step = "all")
        )
      ),
      rangeslider = list(visible = TRUE) # Agregar slider
    ),
    yaxis = list(title = ""),
    hovermode = "x"
  )

# Mostrar la gráfica interactiva
fig



```

Para eliminar la tendencia de la serie, se aplicó la diferenciación ordinaria. La serie resultante muestra fluctuaciones alrededor de cero, lo que indica que la tendencia ha sido eliminada y facilita el análisis de su estacionariedad.

### Promedio móvil

Para extraer la tendencia mediante un promedio móvil, se utilizó la descomposición clásica de la serie temporal. Al restar la componente de tendencia obtenida, se obtiene una serie sin la estructura de largo plazo, permitiendo observar mejor las fluctuaciones alrededor de un nivel estable. La serie resultante muestra variaciones más centradas, lo que facilita el análisis posterior de estacionariedad y comportamiento estocástico.


```{r OroPromMov}
#| echo: false

DescomProm=decompose(Oro_lamb)
ExtraProm=Oro_lamb-DescomProm$trend
plot_ly( x = DatosO$Fecha, y = ExtraProm, type = 'scatter', mode = 'lines',color=I("gold")) %>%
  layout(title = 'Precio Oro regalías con tendencia extraída (Promedio móvil)',
         xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))
```

### Comparación de las funciones de autocorrelación de las series sin tendencia

```{r}
#| echo: false
par(mfrow = c(2, 2))
acf(bmnoLM,lag.max =100,main="Autocorrelación serie sin tendencia lineal")
acf(STLextra,lag.max =100,main="Autocorrelación serie sin tendencia STL")
acf(DiferenciaOrd,lag.max =100,main="Autocorrelación serie sin tendencia\npor diferencia ordinaria")
acf(ExtraProm[7:282],lag.max =100,main="Autocorrelación serie sin tendencia\npor promedio móvil")
par(mfrow = c(1, 1))
```

El análisis de autocorrelación (ACF) permitió evaluar el impacto de los distintos métodos de eliminación de tendencia en la serie de tiempo. Se encontró que, aunque la eliminación de tendencia mediante modelos lineales, suavizado por STL y promedio móvil reducen la autocorrelación en distintos grados, en todos los casos persisten patrones que sugieren que la serie aún conserva cierta estructura de largo plazo. En contraste, la diferenciación ordinaria mostró la mayor reducción en la autocorrelación, con valores cercanos a cero en la mayoría de los rezagos, lo que indica que es el método más efectivo para obtener una serie estacionaria y adecuada para modelado.


## Hurtos

De la gráfica principal podemos ver que la tendencia podría seguir una función cuadrática; aunque hay intervalos en el tiempo donde podría no seguir el valor medio de la serie.

Ajustamos un modelo lineal normal a los datos.


```{r HurtosLineal}
#| echo: false

# Regresión lineal cuadrática

HurtosLineal <- lm(formula = Hurtos_lamb ~ time(Hurtos_lamb) + I(time(Hurtos_lamb)^2))

HurtosLinealDF <- data.frame(cbind(time(Hurtos_lamb),HurtosLineal$fitted.values))

plot.ts(Hurtos_lamb, col = 'purple', main = 'Hurtos transformada tendencia Reg. Lineal.')
lines(x = unclass(time(Hurtos_lamb)), y = HurtosLineal$fitted.values, lwd = 3, col = 'red')


```

Como se puede ver la tendencia estimada por medio de una regresión lineal normal tiene problemas en el ajuste de algunos períodos de tiempo; comprendiendo los inicios de 2005 y los primeros meses del 2020 y la tendencia cuadrática no sigue el año del 2025. 

Por lo tanto, se eliminara la tendencia y se usará la primera diferencia ordinaria.

```{r HurtosDiff}
#| echo: false

DatosH <- DatosH |> 
  mutate(Diff = c(NA,diff(Hurtos_lamb)))

fig <- plot_ly(DatosH, x = ~Fecha, y = ~ Diff, type = 'scatter', mode = 'lines',line = (list(color='purple'))) %>%
  layout(
    title = "Hurtos transformada primera diferencia.",
    xaxis = list(
      title = "Fecha",
      rangeselector = list( # Botones de zoom rápido
        buttons = list(
          list(count = 1, label = "1m", step = "month", stepmode = "backward"),
          list(count = 6, label = "6m", step = "month", stepmode = "backward"),
          list(count = 1, label = "1y", step = "year", stepmode = "backward"),
          list(step = "all")
        )
      ),
      rangeslider = list(visible = TRUE) # Agregar slider
    ),
    yaxis = list(title = ""),
    hovermode = "x"
  )

fig


```




:::

# Componente estacional.



::: panel-tabset
## Oro

### Mapa de calor

Para evaluar la presencia de estacionalidad en la serie sin tendencia, se construyó un mapa de calor con la serie diferenciada. En este gráfico, los valores se representan en función del tiempo para identificar posibles patrones estacionales.

```{r OroHeatMap}
#| echo: false
#| warning: false
TSstudio::ts_heatmap(DiferenciaOrd,title = "Mapa de Calor - Precio Oro regalías(Diferencia Ordinaria)", color="Reds")

```
Sin embargo, el mapa de calor no muestra patrones claros de valores altos o bajos en meses específicos, lo que sugiere que la serie no presenta una estacionalidad evidente. Esto indica que, al menos visualmente, no hay meses con incrementos o disminuciones sistemáticas en el precio del oro por regalías.

### Subseries por meses

Para complementar el análisis de estacionalidad, se realizó una gráfica de subseries que permite observar la evolución promedio de la serie diferenciada en cada mes del año.


```{r OroMeses}
#| echo: false
monthplot(DiferenciaOrd,main="Subseries(Diferencia Ordinaria)")
```

En este gráfico, no se identifican diferencias significativas entre los meses, lo que refuerza la conclusión obtenida con el mapa de calor: no se evidencia un patrón estacional claro en la serie.

### Boxplot por meses

```{r OroMesesBoxPlot}
#| echo: false
tsibbleDesem<-tsibble::as_tsibble(Oro_lamb)
tsibbleDesem <- tsibbleDesem %>%
  mutate(index = zoo::as.Date(index))
tsibbleDesem<-tsibbleDesem%>%mutate(Diferencia=value-lag(value))
tsibbleDesem %>%
  na.omit() %>%
  timetk::plot_seasonal_diagnostics(.date_var = index, .value = Diferencia, .feature_set = c("month.lbl"), .geom = "boxplot")
```


Los resultados indican que no hay una estacionalidad fuerte, ya que las medianas mensuales son bastante similares y no se observa un patrón claro de meses con valores consistentemente altos o bajos.

Si bien algunos meses, como abril y noviembre, presentan una mayor cantidad de valores atípicos, esto sugiere la presencia de eventos aislados en lugar de un comportamiento estacional estructurado. Además, la dispersión de los datos es relativamente homogénea entre los meses, reforzando la conclusión de que la serie diferenciada no muestra una estacionalidad significativa.

```{r OroKruskalWallis}
#| echo: false
df_estacionalidad <- data.frame(
  Mes = factor(format(zoo::as.Date(time(DiferenciaOrd)), "%m")),  
  Valor = as.numeric(DiferenciaOrd)
)

kruskal.test(Valor ~ Mes, data = df_estacionalidad)
```
El valor p obtenido es 0.2289, que es mayor que 0.05. Esto significa que no hay evidencia suficiente para rechazar la hipótesis nula, lo que indica que no hay diferencias significativas entre los meses en la serie diferenciada.

En otras palabras, no se detecta estacionalidad significativa en la serie después de aplicar la diferenciación ordinaria. Esto concuerda con los gráficos previos (mapa de calor, subseries y boxplots por mes), donde tampoco se observaba un patrón estacional claro.


## Hurtos

Vamos a explorar la componente estacional usando la serie con la varianza estabilizada y en primera diferencia.


Hay 8028 observaciones, por lo tanto el calculo de autocorrelaciones confiables podrían estar entre 90y 507 rezagos!.



```{r HurtoACFDiff}
#| echo: false
#| warning: false
forecast::Acf(DatosH$Diff , lag.max = 90)

```

La mayor autocorrelación positiva es cada 7 días. Hay autocorrelaciones negativas en cada 2, 3, 4, 5 días.



```{r HurtosPeriodograma}
#| echo: false
#| warning: false


# Objeto ts cafe transformada
Hurtos_lambDiff <- diff(Hurtos_lamb)

Hurtos <- tsibble::as_tsibble(Hurtos_lambDiff)
# Periodograma
PeriodogramHurtos <- stats::spectrum(Hurtos_lambDiff, log = 'no', main='Periodograma')

frecuencias = PeriodogramHurtos$freq
Periodograma = PeriodogramHurtos$spec

for (i in 1:3){
  ind = which.max(Periodograma)
  cat('Valor ', i, ' donde se máximiza el periodograma es P(f)= ', Periodograma[ind], 'con frecuencia f=', frecuencias[ind],'\n')
  abline(v = frecuencias[ind], col = 'blue', lty = i, lwd=4-i)
  Periodograma = Periodograma[-ind]
  frecuencias = frecuencias[-ind]
}


```



```{r Subseries}
#| echo: false
#| warning: false


Hurtos_lambDiffTSB <- tsibble::as_tsibble(Hurtos_lambDiff)



start_date <- as.Date("2003-01-02")

# 1. Transformar la serie ts en un tibble con fechas diarias
Hurtos_df <- tibble(
  date  = seq.Date(
    from = start_date,
    by   = "day",
    length.out = length(Hurtos_lambDiff)  # Coincide con la longitud de tu ts
  ),
  value = as.numeric(Hurtos_lambDiff)      # Aseguramos que sea numérico
)

# 2. Convertir a tsibble
Hurtos_tsibble <- Hurtos_df %>%
  tsibble::as_tsibble(index = date)

# 3. Visualizar estacionalidad semanal con gg_season()
feasts::gg_season(Hurtos_tsibble, value, period = "week") +
  labs(title = "Estacionalidad Semanal (gg_season)",
       x = "Día de la semana",
       y = "Valor")

# 4. Visualizar estacionalidad semanal con gg_subseries()
feasts::gg_subseries(Hurtos_tsibble, value, period = "week") +
  labs(title = "Estacionalidad Semanal (gg_subseries)",
       x = "Día de la semana",
       y = "Valor")
```




:::

# Relaciones no lineales.

Con el fin de configurar los modelos de aprendizaje supervizado como una regresión y escoger hiperparámetros que permitan capturar las relaciones no lineales haremos uso de los gráficos de retardos.


Para detectar si hay una relaciones no lineales, se realiza un gráfico de lags que permite dar un diagnóstico incial de manera visual.


```{r librerias2}
#| echo: false
#| warning: false

library(tidyr)
library(tseries)
library(TSA)
library(zoo)

Hurtos <- ts(data = DatosH$Cantidad, start = c(2003, 01), frequency = 365)

```



::: panel-tabset
## Oro

Para evaluar la dependencia temporal en la serie diferenciada, se realizaron gráficos de dispersión entre los valores actuales y sus rezagos $(t−1,t−2,\ldots,t−12)$.

```{r OroLags}
#| echo: false
par(mar = c(3,2,3,2))
astsa::lag1.plot(DiferenciaOrd, 12,corr=T)
```
Los diagramas de dispersión no muestran una relación clara entre los valores pasados y presentes. Los coeficientes de correlación en los distintos rezagos son bajos y cercanos a cero, lo que sugiere que la serie diferenciada no presenta una dependencia temporal fuerte. En particular:

-   La correlación con el primer rezago ($t−1$), aunque débil, es la más alta entre todos los rezagos analizados. Esto sugiere que el proceso podría tener una dependencia temporal limitada, con una ligera influencia del valor inmediatamente anterior, pero sin una memoria significativa a largo plazo.

-   No se identifican patrones cíclicos ni evidencia de estacionalidad en rezagos como $t−12$ (que correspondería a un patrón anual).


```{r CafeRetardos}
#| echo: false
#| warning: false
#| include: false

# astsa::lag1.plot(Cafe_lambDiff, max.lag = 25,corr=T) 
# No parecen haber rezagos que tengan relaciones no lineales.
# TSstudio::ts_lags(Cafe_lambDiff, lags = 1:24) # tipo plotly
```




## Hurtos


```{r echo = FALSE, message = FALSE, warning = FALSE}

## Lag plot
DatosH_lagged <- DatosH %>%
  mutate(across(Cantidad, list(
    lag1 = ~ lag(., 1),
    lag2 = ~ lag(., 2),
    lag3 = ~ lag(., 3),
    lag4 = ~ lag(., 4),
    lag5 = ~ lag(., 5),
    lag6 = ~ lag(., 6),
    lag7 = ~ lag(., 7),
    lag8 = ~ lag(., 8),
    lag9 = ~ lag(., 9),
    lag10 = ~ lag(., 10),
    lag11 = ~ lag(., 11),
    lag12 = ~ lag(., 12)
  )))


# Se reajusta el dataframe
DatosH_long <- DatosH_lagged %>%
  pivot_longer(
    cols = starts_with("Cantidad_lag"),
    names_to = "Lag",
    values_to = "Lagged_Cantidad"
  ) %>%
  mutate(Lag = as.numeric(stringr::str_extract(Lag, "[0-9]+"))) %>%
  filter(!is.na(Lagged_Cantidad))



# Gráfico de lags
ggplot(DatosH_long, aes(x = Cantidad, y = Lagged_Cantidad)) +
  geom_point(alpha = 0.5) +
  facet_wrap(~Lag, ncol = 4) +
  labs(
    title = "Gráfico de lags",
    x = "",
    y = "",
    caption = "n = 1 hasta 12"
  ) +
  theme_bw() +
  theme(panel.spacing = unit(1, "lines")) +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") # Línea diagonal
```

Aparentemente la serie presenta relaciones no lineales. Para dar un veredicto más confiable, podemos utilizar los tests BDS y Tsay que en caso ser rechazados, nos indicarían que las series no son lineales.

***Test BDS***

```{r}
#| echo: false

bds.test(Hurtos)
```

***Test Tsay***

```{r}
#| echo: false

Tsay.test(Hurtos) # Rechaza linealidad
```

Ambos tests rechazan la hipótesis nula de linealidad. Podemos corroborarlo observando los promedios y desviaciones estándar móviles que a lo largo de la serie sostienen un comportamiento inestable.

```{r echo = FALSE, message = FALSE, warning = FALSE}

## Media y desviación estándar móvil
DatosH <- DatosH %>%
  mutate(
    rolling_mean = rollmean(Cantidad, k = 12, fill = NA),
    rolling_sd = rollapply(Cantidad, width = 12, FUN = sd, fill = NA)
  )

ggplot(DatosH, aes(x = Fecha)) +
  geom_line(aes(y = Cantidad), color = "gray") +
  geom_line(aes(y = rolling_mean), color = "blue", linewidth = 1) +
  geom_line(aes(y = rolling_sd), color = "red", linewidth = 1) +
  labs(title = "Promedio y desviación estándar móvil", x = "Fecha", y = "Cantidad", color = "") +
  theme_minimal()
```

Observando el suavizamiento LOESS vemos algunas fluctuaciones en el corto plazo y una relación no lineal en el largo plazo.

```{r echo = FALSE, message = FALSE, warning = FALSE}

## Loess
ggplot(DatosH, aes(x = Fecha, y = Cantidad)) +
  geom_line(alpha = 0.5) +
  geom_smooth(method = "loess", color = "red", linewidth = 1.2) +
  labs(title = "LOESS para la serie de Hurtos de Vehículos", x = "Fecha", y = "Cantidad") +
  theme_minimal()
```

Sería una buena práctica en este caso implementar y comparar un modelo ARIMA con alguno más complejo que permita capturar mejor la volatilidad como por ejemplo LSTM o GARCH.


:::
